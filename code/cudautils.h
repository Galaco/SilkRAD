#ifndef __CUDAUTILS_H_
#define __CUDAUTILS_H_

#include <iostream>
#include <cstdlib>
#include <cstdio>

#include "cuda_runtime.h"
#include "device_launch_parameters.h"


inline void cuda_assert(
        cudaError_t code, const char* file, int line,
        bool abort=true
        ) {

    if (code != cudaSuccess) {
        std::cerr << "cuda_assert(): "
            << cudaGetErrorString(code) << " (File '"
            << file << "', Line "
            << line << ")"
            << std::endl;

        if (abort) {
            exit(code);
        }
    }
}


//inline __device__ __host__ cudaError_t _cudaMalloc(void** ptr, size_t size) {
//    printf("Allocate %u\n", static_cast<unsigned int>(size));
//    return cudaMalloc(ptr, size);
//}
//
//
//#define cudaMalloc(ptr, size) _cudaMalloc(reinterpret_cast<void**>(ptr), (size))


#define CUDA_CHECK_ERROR(ans) do {\
    cuda_assert((ans), __FILE__, __LINE__);\
} while (0)


#define CUDA_CHECK_ERROR_DEVICE(code) do {\
    if ((code) != cudaSuccess) {\
        printf(\
            "CUDA Device Error: %s (File '%s', Line %d)\n",\
            cudaGetErrorString(code), __FILE__, __LINE__\
        );\
        return;\
    }\
} while (0)


#define CUDA_RETRY_UNTIL_SUCCESS(action) while (1) {\
    cudaError code = (action);\
    if (code == cudaSuccess) {\
        break;\
    }\
    else {\
        printf(\
            "CUDA Device Error: %s (File '%s', Line %d)... Retrying!\n",\
            cudaGetErrorString(code), __FILE__, __LINE__\
        );\
    }\
}


// If we don't do this, Visual Studio will keep flipping its $#!& because it
// apparently can't parse kernel launch syntax correctly.
#define KERNEL_LAUNCH(kernel, gridDim, blockDim, ...) do {\
    kernel<<<gridDim, blockDim>>>(__VA_ARGS__);\
    CUDA_CHECK_ERROR(cudaPeekAtLastError());\
} while (0)


#define KERNEL_LAUNCH_SHARED(kernel, gridDim, blockDim, shared, ...) do {\
    kernel<<<gridDim, blockDim, shared>>>(__VA_ARGS__);\
    CUDA_CHECK_ERROR(cudaPeekAtLastError());\
} while (0)


#define KERNEL_LAUNCH_DEVICE(kernel, gridDim, blockDim, ...) do {\
    kernel<<<gridDim, blockDim>>>(__VA_ARGS__);\
    CUDA_CHECK_ERROR_DEVICE(cudaPeekAtLastError());\
} while (0)


#define KERNEL_LAUNCH_SHARED_DEVICE(kernel, gridDim, blockDim, shared, ...) \
do {\
    kernel<<<gridDim, blockDim, shared>>>(__VA_ARGS__);\
    CUDA_CHECK_ERROR_DEVICE(cudaPeekAtLastError());\
} while (0)


inline __host__ __device__ size_t div_ceil(size_t a, size_t b) {
    return (a + b - 1) / b;
}


/** Hack to get the Windows WDDM thingy to work properly. */
inline __host__ void flush_wddm_queue(void) {
    cudaEvent_t event;

    CUDA_CHECK_ERROR(cudaEventCreate(&event));
    CUDA_CHECK_ERROR(cudaEventRecord(event));

    cudaEventQuery(event);

    // Acknowledge and ignore the error generated by cudaEventQuery().
    cudaGetLastError();
}


inline __host__ __device__ float3 make_float3(const BSP::Vec3<float>& f) {
    return make_float3(f.x, f.y, f.z);
}


inline __host__ __device__ float dot(const float3& a, const float3& b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}


inline __host__ __device__ float3 cross(const float3& a, const float3& b) {
    return make_float3(
        a.y * b.z - a.z * b.y,
        a.z * b.x - a.x * b.z,
        a.x * b.y - a.y * b.x
    );
}


inline __host__ __device__ float3 operator-(
        const float3& a, const float3& b
        ) {
    return make_float3(a.x - b.x, a.y - b.y, a.z - b.z);
}


inline __host__ __device__ float3 operator+(
        const float3& a, const float3& b
        ) {
    return make_float3(a.x + b.x, a.y + b.y, a.z + b.z);
}


inline __host__ __device__ float3& operator+=(
        float3& a, const float3& b
        ) {
    a.x += b.x;
    a.y += b.y;
    a.z += b.z;
    return a;
}


inline __host__ __device__ float3& operator-=(
        float3& a, const float3& b
        ) {
    a.x -= b.x;
    a.y -= b.y;
    a.z -= b.z;
    return a;
}


inline __host__ __device__ float3 operator*(const float3& v, float c) {
    return make_float3(v.x * c, v.y * c, v.z * c);
}


inline __host__ __device__ float3 operator*=(float3& a, float c) {
    a.x *= c;
    a.y *= c;
    a.z *= c;
    return a;
}


inline __host__ __device__ float3 operator*(float c, const float3& v) {
    return v * c;
}


inline __host__ __device__ float3 operator/(const float3& v, float c) {
    return v * (1.0 / c);
}


inline __host__ __device__ float3 operator/=(float3& a, float c) {
    a.x /= c;
    a.y /= c;
    a.z /= c;
    return a;
}


inline __host__ __device__ float dist(const float3& a, const float3& b) {
    float3 diff = b - a;
    return sqrt(dot(diff, diff));
}


inline __host__ __device__ float len(const float3& v) {
    return dist(make_float3(0.0, 0.0, 0.0), v);
}


inline __host__ __device__ float3 normalized(const float3& v) {
    return v / len(v);
}


#endif
